/**
 * Import necessary modules from firebase-functions and firebase-admin.
 */
import * as functions from "firebase-functions";
import * as admin from "firebase-admin";

// Initialize the Firebase Admin SDK.
// This allows our functions to securely interact with Firestore.
admin.initializeApp();
const db = admin.firestore();

// Import VIP notification functions
export * from "./vipNotifications";

// ###################################################################################################
// ##                                                                                               ##
// ##  1. SECURE RECEIPT VALIDATION FUNCTION                                                        ##
// ##                                                                                               ##
// ###################################################################################################
//
// PURPOSE:
// To provide a secure, server-side mechanism for validating in-app purchase receipts
// from Apple and Google. This is the *only* reliable way to confirm a purchase is legitimate
// and prevents users from fraudulently unlocking premium content.
//
// TRIGGER:
// This is an "onCall" function, meaning it's a secure HTTPS endpoint that can only be
// called from within our app by an authenticated user.
//
// PARAMETERS FROM APP:
// - `receiptData`: The raw receipt data from the purchase.
// - `productId`: The ID of the product that was purchased.
// - `platform`: A string, either 'ios' or 'android'.
//
// LOGIC:
// 1. Authenticate the user calling the function.
// 2. Prepare the receipt for validation with the appropriate service.
// 3. (NEEDS IMPLEMENTATION) Use a third-party library (like 'in-app-purchase') to send the
//    receipt to Apple's or Google's servers for validation.
// 4. If the receipt is valid, determine the subscription duration (monthly/annual).
// 5. Calculate the new subscription expiry date.
// 6. Update the user's document in Firestore with their new subscription status, tier,
//    and expiry date.
// 7. Return a success message to the app.

export const validatePurchase = functions.https.onCall(async (data, context) => {
  // 1. Ensure the user is authenticated.
  if (!context.auth) {
    throw new functions.https.HttpsError(
      "unauthenticated",
      "The function must be called while authenticated."
    );
  }

  const userId = context.auth.uid;
  const { receiptData, productId, platform } = data;

  // 2. Validate input from the app.
  if (!receiptData || !productId || !platform) {
    throw new functions.https.HttpsError(
      "invalid-argument",
      "Missing required purchase data."
    );
  }

  // 3. TODO: Implement receipt validation logic.
  // This is where you would use a library like 'in-app-purchase' to
  // connect to Apple/Google and verify the receipt. This is a placeholder.
  const isValid = true; // Assume valid for this blueprint.

  if (isValid) {
    // 4. If valid, determine subscription details.
    const isAnnual = productId.includes("annual");
    const tier = productId.includes("pro") ? "pro" : "plus";
    const now = new Date();
    const expiryDate = new Date(
      now.getFullYear() + (isAnnual ? 1 : 0),
      now.getMonth() + (isAnnual ? 0 : 1),
      now.getDate()
    );

    // 5. Update the user's profile in Firestore.
    try {
      await db.collection("users").doc(userId).update({
        subscriptionTier: tier,
        subscriptionExpiryDate: admin.firestore.Timestamp.fromDate(expiryDate),
        isSubscribed: true, // You might use this field as a quick check
      });
      functions.logger.info(`Successfully granted ${tier} subscription to ${userId}`);
      return { status: "success", message: "Subscription granted." };
    } catch (error) {
      functions.logger.error("Error updating user profile:", error);
      throw new functions.https.HttpsError(
        "internal",
        "Failed to update user profile."
      );
    }
  } else {
    throw new functions.https.HttpsError(
      "permission-denied",
      "Receipt validation failed."
    );
  }
});


// ###################################################################################################
// ##                                                                                               ##
// ##  2. LEADERBOARD REWARDS FUNCTION                                                              ##
// ##                                                                                               ##
// ###################################################################################################
//
// PURPOSE:
// To automatically reward the top players on the leaderboard with a free subscription,
// fostering competition and rewarding engagement.
//
// TRIGGER:
// This is a "scheduled" function that runs automatically. The schedule is defined using
// standard cron syntax. "0 0 1 * *" means "at 00:00 on day-of-month 1".
//
// LOGIC:
// 1. Query the 'users' collection in Firestore.
// 2. Order the users by their 'points' in descending order.
// 3. Limit the results to the top 15 users.
// 4. For each of the top 15 users, update their document to grant them a one-month
//    Pro subscription.
// 5. The function handles both new subscriptions and extending existing ones.
// 6. (NEW) After granting rewards, the function will iterate through all users
//    to reset their monthly stats (e.g., 'monthlyEntries').

export const grantTopPlayerRewards = functions.pubsub
  .schedule("0 0 1 * *") // Runs at midnight on the 1st of every month
  .onRun(async (context) => {
    functions.logger.info("Running monthly leaderboard rewards function...");

    try {
      // 1. Query for the top 15 users by points.
      const snapshot = await db.collection("users")
        .orderBy("points", "desc")
        .limit(15)
        .get();

      if (snapshot.empty) {
        functions.logger.info("No users found. Exiting function.");
        return null;
      }

      // 2. Prepare to grant rewards.
      const batch = db.batch();
      const now = new Date();
      // Set expiry to the first day of the *next* month.
      const expiryDate = new Date(now.getFullYear(), now.getMonth() + 1, 1);

      // 3. Iterate and update each winner's document.
      snapshot.docs.forEach((doc) => {
        const userRef = doc.ref;
        functions.logger.info(`Granting Pro subscription to user ${doc.id}`);
        batch.update(userRef, {
          subscriptionTier: "pro",
          subscriptionExpiryDate: admin.firestore.Timestamp.fromDate(expiryDate),
          isSubscribed: true,
        });
      });

      // 4. Commit all updates at once.
      await batch.commit();
      functions.logger.info(`Successfully awarded ${snapshot.size} users.`);

      // 5. (NEW) Reset monthly stats for all users.
      // This is a separate operation. For very large user bases, this should be
      // handled with a more robust batching or queueing system.
      functions.logger.info("Starting to reset monthly stats for all users...");
      const allUsersSnapshot = await db.collection("users").get();
      const resetBatch = db.batch();
      allUsersSnapshot.docs.forEach((doc) => {
        resetBatch.update(doc.ref, { monthlyEntries: 0 });
      });
      await resetBatch.commit();
      functions.logger.info(`Successfully reset monthly stats for ${allUsersSnapshot.size} users.`);

      return null;
    } catch (error) {
      functions.logger.error("Error granting leaderboard rewards:", error);
      return null;
    }
  });
